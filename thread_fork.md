 <br />当一个线程调用函数fork的时候，整个进程地址空间会被拷贝到子进程中，在8.3节中有提到copy-on-write.子进程是一个与父进程完全不同的进程，但是如果父进程和子进程都没有对内存内容进行修改，那么该内存页就可以在父进程与子进程之间进行共享。 
 <br />通过继承父进程的整个地址空间，子进程也会继承父进程每个互斥锁，读写锁以及条件变量的状态，如果父进程包含了多个线程，而且在fork函数返回之后并不会立即调用exec的话，子进程就需要清除锁状态。 
 <br />在fork后的子进程内部，只会出现一个线程，它是父进程中调用fork函数的线程的拷贝。如果父进程中任何线程锁定了锁，相同的锁在子进程中也会处于锁定状态，问题是子进程并没有包含锁定锁的线程的拷贝，因此子进程没有办法知道哪一个锁需要锁定以及哪一个锁需要解除锁定。 
 <br />上述问题可以通过如下方法避免：在fork之后调用函数exec，在这种情况下，老的地址空间将被抛弃，因此锁定状态并不重要。然而，这种方法并不总是可行的，如果子进程需要继续运行，那么我们就需要使用一个不同的策略。 
 <br />为了避免在一个多线程进程中不一致的状态，POSIX.1指出在fork返回之后到exec函数之前的时间内只能调用异步信号安全的函数。这限制了子进程在调用exec之前可以做的事情，但是并不能解决子进程中锁状态的问题。 
为了清除锁状态，我们可以建立fork handler来进行处理。
