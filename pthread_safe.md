

可重入与异步信号安全
一个可重入的函数简单来说就是可以被中断的函数，也就是说，可以在这个函数执行的任何时刻中断它，转入OS调度下去执行另外一段代码，而返回控制时不会出现什么错误。
《多线程编程指南》中定义，可以被信号控制器安全调用的函数被称为"异步信号安全"函数。
因此，我认为可重入与异步信号安全是一个概念。

有人将可重入函数与线程安全函数混为一谈，我认为是不正确的。

这里引用CSAPP中的描述来说明一下：
--------------------------------------------------
CSAPP
13.7.1 线程安全
一个函数被称为线程安全的，当且仅当被多个并发线程反复的调用时，它会一直产生正确的结果。
13.7.2 可重入性
有一类重要的线程安全函数，叫做可重入函数，其特点在于它们具有一种属性：当它们被多个线程调用时，不会引用任何共享的数据。

尽管线程安全和可重入有时会（不正确的）被用做同义词，但是它们之间还是有清晰的技术差别的。可重入函数是线程安全函数的一个真子集。
--------------------------------------------------

重入即表示重复进入，首先它意味着这个函数可以被中断，其次意味着它除了使用自己栈上的变量以外不依赖于任何环境（包括static），这样的函数就是 purecode（纯代码）可重入，可以允许有该函数的多个副本在运行，由于它们使用的是分离的栈，所以不会互相干扰。
可重入函数是线程安全函数，但是反过来，线程安全函数未必是可重入函数。
实际上，可重入函数很少，APUE 10.6节中描述了Single UNIX Specification说明的可重入的函数，只有115个；APUE 12.5节中描述了POSIX.1中不能保证线程安全的函数，只有89个。

信号就像硬件中断一样，会打断正在执行的指令序列。信号处理函数无法判断捕获到信号的时候，进程在何处运行。如果信号处理函数中的操作与打断的函数的操作 相同，而且这个操作中有静态数据结构等，当信号处理函数返回的时候（当然这里讨论的是信号处理函数可以返回），恢复原先的执行序列，可能会导致信号处理函 数中的操作覆盖了之前正常操作中的数据。
不可重入函数的原因在于：
1> 已知它们使用静态数据结构
2> 它们调用malloc和free.
因为malloc通常会为所分配的存储区维护一个链接表，而插入执行信号处理函数的时候，进程可能正在修改此链接表。
3> 它们是标准IO函数.
因为标准IO库的很多实现都使用了全局数据结构

即使对于可重入函数，在信号处理函数中使用也需要注意一个问题就是errno。一个线程中只有一个errno变量，信号处理函数中使用的可重入函数也有可 能会修改errno。例如，read函数是可重入的，但是它也有可能会修改errno。因此，正确的做法是在信号处理函数开始，先保存errno；在信号 处理函数退出的时候，再恢复errno。

例如，程序正在调用printf输出，但是在调用printf时，出现了信号，对应的信号处理函数也有printf语句，就会导致两个printf的输出混杂在一起。
如果是给printf加锁的话，同样是上面的情况就会导致死锁。对于这种情况，采用的方法一般是在特定的区域屏蔽一定的信号。
屏蔽信号的方法：
1> signal(SIGPIPE, SIG_IGN); //忽略一些信号
2> sigprocmask()
sigprocmask只为单线程定义的
3> pthread_sigmask()
pthread_sigmasks可以在多线程中使用

现在看来信号异步安全和可重入的限制似乎是一样的，所以这里把它们等同看待;-)

线程安全
线程安全：如果一个函数在同一时刻可以被多个线程安全的调用，就称该函数是线程安全的。

不需要共享时，请为每个线程提供一个专用的数据副本。如果共享非常重要，则提供显式同步，以确保程序以确定的方式操作。通过将过程包含在语句中来锁定和解除锁定互斥，可以使不安全过程变成线程安全过程，而且可以进行串行化。

很多函数并不是线程安全的，因为他们返回的数据是存放在静态的内存缓冲区中的。通过修改接口，由调用者自行提供缓冲区就可以使这些函数变为线程安全的。
操作系统实现支持线程安全函数的时候，会对POSIX.1中的一些非线程安全的函数提供一些可替换的线程安全版本。
例如,gethostbyname()是线程不安全的，在Linux中提供了gethostbyname_r()的线程安全实现。
函数名字后面加上"_r"，以表明这个版本是可重入的（对于线程可重入，也就是说是线程安全的，但并不是说对于信号处理函数也是可重入的，或者是异步信号安全的）。

多线程程序中常见的疏忽性问题
1> 将指针作为新线程的参数传递给调用方栈。
2> 在没有同步机制保护的情况下访问全局内存的共享可更改状态。
3> 两个线程尝试轮流获取对同一对全局资源的权限时导致死锁。其中一个线程控制第一种资源，另一个线程控制第二种资源。其中一个线程放弃之前，任何一个线程都无法继续
操作。
4> 尝试重新获取已持有的锁（递归死锁）。
5> 在同步保护中创建隐藏的间隔。如果受保护的代码段包含的函数释放了同步机制，而又在返回调用方之前重新获取了该同步机制，则将在保护中出现此间隔。结果具有误导性。对于调用方，表面上看全局数据已受到保护，而实际上未受到保护。
6> 将UNIX 信号与线程混合时，使用sigwait(2) 模型来处理异步信号。
7> 调用setjmp(3C) 和longjmp(3C)，然后长时间跳跃，而不释放互斥锁。
8> 从对*_cond_wait() 或*_cond_timedwait() 的调用中返回后无法重新评估条件。


总结
判断一个函数是不是可重入函数，在于判断其能否可以被打断，打断后恢复运行能够得到正确的结果。（打断执行的指令序列并不改变函数的数据）
判断一个函数是不是线程安全的，在于判断其能否在多个线程同时执行其指令序列的时候，保证每个线程都能够得到正确的结果。

如果一个函数对多个线程来说是可重入的，则说这个函数是线程安全的，但这并不能说明对信号处理程序来说该函数也是可重入的。
如果函数对异步信号处理程序的重入是安全的，那么就可以说函数是"异步-信号安全"的。


线程安全函数
• 概念：
线程安全的概念比较直观。一般说来，一个函数被称为线程安全的，当且仅当被多个并发线程反复调用时，它会一直产生正确的结果。
• 确保线程安全：
要确保函数线程安全，主要需要考虑的是线程之间的共享变量。属于同一进程的不同线程会共享进程内存空间中的全局区和堆，而私有的线程空间则主要包括栈和寄 存器。因此，对于同一进程的不同线程来说，每个线程的局部变量都是私有的，而全局变量、局部静态变量、分配于堆的变量都是共享的。在对这些共享变量进行访 问时，如果要保证线程安全，则必须通过加锁的方式。
• 线程不安全的后果：
线程不安全可能导致的后果是显而易见的——共享变量的值由于不同线程的访问，可能发生不可预料的变化，进而导致程序的错误，甚至崩溃。

    可重入函数
• 概念：
可重入的概念基本没有比较正式的完整解释，多数的文档都只是说明什么样的情况才能保证函数可重入，但没有完整定义。按照Wiki上的说法，“A computer program or routine is described as reentrant if it can be safely executed concurrently; that is, the routine can be re-entered while it is already running.”根据笔者的经验，所谓“重入”，常见的情况是，程序执行到某个函数foo()时，收到信号，于是暂停目前正在执行的函数，转到信号处理 函数，而这个信号处理函数的执行过程中，又恰恰也会进入到刚刚执行的函数foo()，这样便发生了所谓的重入。此时如果foo()能够正确的运行，而且处 理完成后，之前暂停的foo()也能够正确运行，则说明它是可重入的。
• 确保可重入：
要确保函数可重入，需满足以下几个条件：
1、不在函数内部使用静态或全局数据
2、不返回静态或全局数据，所有数据都由函数的调用者提供。
3、使用本地数据，或者通过制作全局数据的本地拷贝来保护全局数据。
4、不调用不可重入函数。
• 不可重入的后果：
不可重入的后果主要体现在象信号处理函数这样需要重入的情况中。如果信号处理函数中使用了不可重入的函数，则可能导致程序的错误甚至崩溃。
